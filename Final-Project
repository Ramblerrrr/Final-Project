{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# NSD Final Project\n",
    "\n",
    "# Title: Dynamic hedging of single option with transaction costs: an optimization approach by  receding horizon control and stochastic programming.\n",
    "\n",
    "$$\n",
    "\\newcommand{\\supp}{\\mathrm{supp}}\n",
    "\\newcommand{\\E}{\\mathbb{E} }\n",
    "\\newcommand{\\Eof}[1]{\\mathbb{E}\\left[ #1 \\right]}\n",
    "\\def\\Cov{{ \\mbox{Cov} }}\n",
    "\\def\\Var{{ \\mbox{Var} }}\n",
    "\\newcommand{\\1}{\\mathbf{1} }\n",
    "\\newcommand{\\PP}{\\mathbb{P} }\n",
    "\\newcommand{\\Pof}[1]{\\mathbb{P}\\left[ #1 \\right]}\n",
    "%\\newcommand{\\Pr}{\\mathrm{Pr} }\n",
    "\\newcommand{\\QQ}{\\mathbb{Q} }\n",
    "\\newcommand{\\RR}{\\mathbb{R} }\n",
    "\\newcommand{\\DD}{\\mathbb{D} }\n",
    "\\newcommand{\\HH}{\\mathbb{H} }\n",
    "\\newcommand{\\spn}{\\mathrm{span} }\n",
    "\\newcommand{\\cov}{\\mathrm{cov} }\n",
    "\\newcommand{\\sgn}{\\mathrm{sgn} }\n",
    "\\newcommand{\\HS}{\\mathcal{L}_{\\mathrm{HS}} }\n",
    "%\\newcommand{\\HS}{\\mathrm{HS} }\n",
    "\\newcommand{\\trace}{\\mathrm{trace} }\n",
    "\\newcommand{\\LL}{\\mathcal{L} }\n",
    "%\\newcommand{\\LL}{\\mathrm{L} }\n",
    "\\newcommand{\\s}{\\mathcal{S} }\n",
    "\\newcommand{\\ee}{\\mathcal{E} }\n",
    "\\newcommand{\\ff}{\\mathcal{F} }\n",
    "\\newcommand{\\hh}{\\mathcal{H} }\n",
    "\\newcommand{\\bb}{\\mathcal{B} }\n",
    "\\newcommand{\\dd}{\\mathcal{D} }\n",
    "\\newcommand{\\g}{\\mathcal{G} }\n",
    "\\newcommand{\\p}{\\partial}\n",
    "\\newcommand{\\half}{\\frac{1}{2} }\n",
    "\\newcommand{\\T}{\\mathcal{T} }\n",
    "\\newcommand{\\bi}{\\begin{itemize}}\n",
    "\\newcommand{\\ei}{\\end{itemize}}\n",
    "\\newcommand{\\beq}{\\begin{equation}}\n",
    "\\newcommand{\\eeq}{\\end{equation}}\n",
    "\\newcommand{\\beas}{\\begin{eqnarray*}}\n",
    "\\newcommand{\\eeas}{\\end{eqnarray*}}\n",
    "\\newcommand{\\cO}{\\mathcal{O}}\n",
    "\\newcommand{\\cF}{\\mathcal{F}}\n",
    "\\newcommand{\\cL}{\\mathcal{L}}\n",
    "\\newcommand{\\BS}{\\text{BS}}\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Abstract\n",
    "In this project, we extend the Black-Merton-Scholes dynamic hedging model proposed in class to make it closer to the real trading situation. We add transaction costs as constraints to the option trading model, then we use a new methodology for discrete time dynamic hedging with transaction costs. This methodology is an optimization approached by Receding horizon control and stochastic programming, which means a general method for investment could be found to make the stability of our investment reach the approximate maximum through the data simulation of Monte Carlo method, although all decisions are made in discrete time. Through comparing the simulation results with the traditional Black–Scholes delta hedging strategy, we can see the advantages of this methology in the investment with transaction costs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Table of content \n",
    "* Introduction\n",
    "* Dynamic hedging problem overview \n",
    "    -  Black–Scholes delta hedging review \n",
    "* Receding horizon control and stochastic program (RHC&SP) hedging\n",
    "* An example on RHC&SP hedging\n",
    "    - Back test and comparison with Black–Scholes delta hedging\n",
    "* Conclusion and discussions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Introduction\n",
    "Dynamic hedging has justifiably been the subject of more and more research within the finance community. We have learnd the traditional Black-Scholes dynamic hedging model in lecture 3 and 4, which is the earliest theory about it and can be used to perfectly hedge a short European call option. In the Black-Scholes dynamic hedging model, we could adjust the shares of underlying asset we hold to let the portfolio reach a continuous hedging relationship which achieves the highest stability. But in a way, this model is too idealistic. In the real hedging process, there will be transaction costs which makes the traditional dynamic hedging strategy can not perform perfectly. Moreover, this model is based on the assumption of continuity of the transaction time, and its strategy may not be reliable in the discrete time transaction.\n",
    "\n",
    "Therefore, we must consider our hedging process from a more general perspective, and we need to implement a strategy different from before.\n",
    "\n",
    "* First, We must be clear that we can only trade in discrete time when we are constructing models and designing strategies. It means we have to choose some independent time points and we can only adjust the number of holdings at these points. Also, We have to deduct the fee that should be paid at the time of each transaction, although we don't want to do so very much.\n",
    "\n",
    "* Second, because of transaction costs, it is difficult for us to get the recommended holding number to reach the optimal result directly. It is a good idea to divide the situation at each time point into several intervals, and then use the same number or strategy on each single interval, this is a good way to simplify our model. In fact, it is this simple idea that inspires the concrete implementation of RHC&SP hedging.\n",
    "\n",
    "* Third, to show that our improvement is actually effective, we need an indicator to evaluate hedging strategies. The dynamic hedging philosophy revolves around the objective of minimizing hedging error. Thus one performance metric that we examine is minimizing the expected hedging error, which we will introduce later. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Dynamic hedging problem overview\n",
    "We have to clarify the general process of a  Dynamic hedging  first — within the consideration of the transaction costs. \n",
    "\n",
    "To begin with, we consider hedging a short European call option on one underlying asset.\n",
    "For simplicity, imagine that the value of the portfolio that we hold at the very beginning is 0. That is to say, we hold 1 call in short position and an amount in cash equal to the Black–Scholes valuation of this call option. As we are considering a discrete time dynamic hedging, we set several rebalancing points before option expiration. At each rebalancing point we adjust our hedging portfolio, which consists of the underlying asset and cash. Of course, the rebalancing must satisfy the self-financing condition.\n",
    "\n",
    "In order to lay out our system dynamics and objectives, we need to start with the definitions as follows:\n",
    "\n",
    "* $S(t)$  : $\\quad$the price of the underlying asset at time t\n",
    "* $c(t)$  :$\\quad$the Black–Scholes value of the call option at time t\n",
    "* $V(t)$  :$\\quad$the value of the hedging portfolio at time t\n",
    "* $T$    :$\\quad$time of expiration of the option\n",
    "* $K$   :$\\quad$strike price of the option\n",
    "* $r$   :$\\quad$risk free interest rate\n",
    "* $N$    :$\\quad$total number of portfolio rebalancings before option expiration\n",
    "* $dt$   :$\\quad$time step between portfolio rebalancing\n",
    "* $g$   :$\\quad$ transaction costs as a% of dollars transacted\n",
    "    \n",
    "Besides, given  information on the underlying asset available at each rebalancing time, a particular hedging methodology arrives at a recommended number of shares of the underlying to hold, which we call $\\Delta(t)$. (In other words, different hedging methodologies correspond to different $\\Delta(t)$.) Then we alter our hedging portfolio to hold this number of shares, pay the transaction costs,  and then place the remaining cash in the risk free asset. At each rebalancing point, we use $V(t-)$ to refer to the hedging portfolio value at time t before the trade is made and $V(t+)$ to refer to the hedging portfolio value at time t after the trade is made.\n",
    "\n",
    "So the general process of a Dynamic hedging with transaction costs can be laid out as follows:\n",
    "\\begin{eqnarray*}\n",
    "&&V(0-) = c_0\\\\\n",
    "&&V(0+) = \\Delta(0)S(0)+[V(0-)-\\Delta(0)S(0)-gS(0)|\\Delta(0)|]\\\\\n",
    "&&...\\\\\n",
    "&&V(t-) = \\Delta(t-dt)S(t)+[V((t-dt)+)-\\Delta(t-dt)S(t-dt)]e^{rdt}\\\\\n",
    "&&V(t+) = \\Delta(t)S(t)+[V(t-)-\\Delta(t)S(t)-gS(t)|\\Delta(t)-\\Delta(t-dt)|]\\\\\n",
    "&&...\\\\\n",
    "&&V(T) = \\Delta(T-dt)S(T)+[V((T-dt)+)-\\Delta(T-dt)S(T-dt)]e^{rdt}\n",
    "\\end{eqnarray*}\n",
    "\n",
    "\n",
    "\n",
    "Traditionally, the dynamic hedging philosophy revolves around the objective of minimizing hedging error, which is shown below:\n",
    "$$\n",
    "\\Eof{\\left|V(T) - c(T)\\right|}\n",
    "$$\n",
    "where $c(T)$ is $\\max\\{S(T)-K,0\\}$, and $V(T)$ is determined by the hedging process above.\n",
    "\n",
    "Generally speaking, our dynamic hedging strategy will show its effect only when we suffer losses, so we can also set our goal to maximize:\n",
    "$$\n",
    "\\Eof{V(T) - c(T)}\n",
    "$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Black–Scholes delta hedging review\n",
    "As we have discussed in Lec03, by maintaining the delta neutrality of the portfolio, we can perform a dynamic hedging. It can be regarded as a special case of the process above, without considering the transaction costs. Specifically, at time $t$, the recommended shares of the underlying to hold $\\Delta(t)$ is\n",
    "\n",
    "$$\n",
    "\\Delta(t) = \\left.\\frac{\\partial c}{\\partial S}\\right|_{t} =N(d_1)= N\\left(\\frac{\\ln(S(t)/K)+(r+\\sigma^2/2)(T-t)}{\\sigma \\sqrt{T-t}}\\right)\n",
    "$$\n",
    "where $N(\\cdot)$ is the distribution function of standard normal distribution.\n",
    "\n",
    "In addition, let $g = 0$, The Black–Scholes delta dynamic hedging process can be expressed as:\n",
    "\\begin{eqnarray*}\n",
    "&&V(0-) = c_0\\\\\n",
    "&&V(0+) = N\\left(\\frac{\\ln(S(0)/K)+(r+\\sigma^2/2)(T)}{\\sigma \\sqrt{T}}\\right)S(0)+[V(0-)-N\\left(\\frac{\\ln(S(0)/K)+(r+\\sigma^2/2)(T)}{\\sigma \\sqrt{T}}\\right)S(0)]\\\\\n",
    "&&...\\\\\n",
    "&&V(t-) = N\\left(\\frac{\\ln(S(t-dt)/K)+(r+\\sigma^2/2)(T-t+dt)}{\\sigma \\sqrt{T-t+dt}}\\right)S(t)+[V((t-dt)+)-N\\left(\\frac{\\ln(S(t-dt)/K)+(r+\\sigma^2/2)(T-t+dt)}{\\sigma \\sqrt{T-t+dt}}\\right)S(t-dt)]e^{rdt}\\\\\n",
    "&&V(t+) = N\\left(\\frac{\\ln(S(t)/K)+(r+\\sigma^2/2)(T-t)}{\\sigma \\sqrt{T-t}}\\right)S(t)+[V(t-)-N\\left(\\frac{\\ln(S(t)/K)+(r+\\sigma^2/2)(T-t)}{\\sigma \\sqrt{T-t}}\\right)S(t)]\\\\\n",
    "&&...\\\\\n",
    "&&V(T) = N\\left(\\frac{\\ln(S(T-dt)/K)+(r+\\sigma^2/2)(dt)}{\\sigma \\sqrt{dt}}\\right)S(T)+[V((T-dt)+)-N\\left(\\frac{\\ln(S(T-dt)/K)+(r+\\sigma^2/2)(dt)}{\\sigma \\sqrt{dt}}\\right)S(T-dt)]e^{rdt}\n",
    "\\end{eqnarray*}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Receding horizon control and stochastic program hedging\n",
    "Black–Scholes delta dynamic hedging is a local optimal solution to some degree. However, as we move away from the conditions set forth by Black–Scholes to a more realistic setting (transaction costs for example) , the solutions are not optimal and performance leaves room for improvement. That's why we introduce other dynamic hedging methodologies. \n",
    "\n",
    "Here we introduce an optimization approach, which is the mixture of stochastic programming and a method from control theory called Receding Horizon Control (RHC) [1]. We call this hedging methology RHC&SP hedging for short. Just like our title, the core of this hedging methology is \"optimization\", which means that we have not selected a specific $\\Delta(t)$ calculation method in advance like delta hedging. But for a specific asset, we let it produce a series of $\\Delta(t)$ for us through model construction and computer simulation.\n",
    "\n",
    "First, let's introduce some background."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Receding horizon control\n",
    "RHC is a feedback control technique, with which an optimization problem is solved at each time step to determine a plan of action over a fixed time horizon. The first input from this plan is applied to the system. At the next time step we repeat the planning process, solving a new optimization problem with the time horizon shifted one step forward [2].\n",
    "\n",
    "Typically, when applying RHC to our optimization problems, with our objective of minimizing hedge error, this can be:\n",
    "$$\n",
    "\\Delta(t) = argmax \\Eof{\\hat{V}(t') - c(t')|S(t)}\n",
    "$$\n",
    "where $t'$ is the next rebalancing point after time $t$, and $\\hat{V}$ is the  estimated portfolio.\n",
    "\n",
    "Note that this traditional version of RHC requires us to estimate values, which is a great difficulty. Even if we do a lot of simulations to estimate the value expectation, it needs to be carried out in every case at each rebalancing point. It is conceivable that the amount of computation must be exponential.\n",
    "\n",
    "To deal with this problem, We add a final time horizon to expiry. This means that in the process of optimization, we play the role of a prophet. Instead of estimating the portfolio value at the next rebalancing point, we get the final objective value directly. So how do we realise it? We will introduce it in detail later."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### hedging with stochastic programming\n",
    "\n",
    "Stochastic programming is a generalization of linear programming. It is a linear programming problem where the coefficients in the constraints and the parameters in the objective function are random variables. \n",
    "\n",
    "As far as our problem is concerned. Our goal is to minimize the hedge error, which can also be considered as maximizing this expression:\n",
    "$$\n",
    "\\Eof{V(T) - c(T)}\n",
    "$$\n",
    "\n",
    "Note that it is not a definite linear expression, but the expectation of a random variable. This is because the price of the underlying asset is uncertain (for example, generally, we believe that it obeys geometric Brownian motion). Moreover, since our constraints are related to the price of the underlying asset, they are also composed of random variables. Because of these, our optimization problem is actually a random programming, not an ordinary linear programming.\n",
    "\n",
    "So how do we solve an stochastic programming problem? In this problem, we use the Monte Carlo simulation approach to stochastic programming, which helps us turn the Stochastic programming problem into a linear programming problem problem [3]. This method means that we have to do a lot of repeated experiments to simulate the path of the underlying asset price, which we call Monte Carlo simulations. (We write the number of simulations as $M$). In this way, each simulation is a definite linear programming system. And then we set our optimization goal as maximizing this expression:\n",
    "$$\n",
    "\\sum_i^{M}(V_i(T) - c_i(T))\n",
    "$$\n",
    "where $V_i(T)$ and $c_i(T)$ stand for the results of the simulation No.i.\n",
    "\n",
    "Note that we do not directly optimize each simulation, but take all variables of these simulations into account to maximize the above expression. It doesn't seem easy. We use Python's gurobipy module to help us achieve this optimization."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Description of RHC&SP hedging process\n",
    "\n",
    "Perhaps what is said above is so abstract that readers think we are talking too much. Then let's explain how the optimization process is implemented — without anything to bluff. \n",
    "\n",
    "The first step is fixing the number of rebalancing points we will include in our optimization, which in our examples is typically two to three. We write $h$ as  the number of time steps. Generally, we set all the time steps except for the final time step to be of size $dt$ although other sizes also generate high levels of performance. \n",
    "\n",
    "We also need to decide upon the number of decision variables at each time step. We store the number of decision variables in a vector called Bins which is of size $h$. Each decision variable corresponds to the number of shares of the underlying to hold at a particular time when the underlying is in a particular price range. For example ,if Bins = [1 5 3] , this means that we have three rebalancing points, and the number of decision variables at each rebalancing point is 1 ,5 and 3. Note that the elements in bins are not decision variables, but the number of decision variables at that time point. Decision variables are the parameters in our optimization problem, but the number of decision variables is set in advance.\n",
    "\n",
    "Let's specifically introduce how decision variables work. Each decision variable is recommended number of shares of the underlying to hold. For example, we consider the third element 3 in Bins, which corresponds to three decision variables. We record the three decision variables as $x_1$, $x_2$ and $x_3$ respectively. Then ,at the third rebalancing point, we divide the price range into 3 ranges (Bingo! the number 3 corresponds to the third element 3 in Bins). The division can be expressed as:\n",
    "$$\n",
    "[0,p_1),\\quad[p_1,p_2),\\quad[p_2,+\\infty)\n",
    "$$\n",
    "\n",
    "They exactly correspond to the 3 decision variables. So we can gain $\\Delta(t)$ as:\n",
    "$$\n",
    "\\Delta(t) = x_i \\quad if \\quad S(t) \\in [p_{i-1},p_i)\n",
    "$$\n",
    "where $i = 1,2,3$, and we supplementary definite $p_0$ as $0$ and $p_4$ as $+\\infty$ . And the situation is similar at other rebalancing points.\n",
    "\n",
    "This raises another question, at each rebalancing point, how do we determine $p_i$? In order to make our distribution as uniform as possible, we introduce such a method. We observe the results of Monte Carlo simulation and set the upper and lower limits for our distribution range. We don't really care about the prices below the lower limit or above the higher limit. Later, we will classify them into the nearest group later. The lower limit $L(t)$ and the higher limit $H(t)$ is definited as:\n",
    "\\begin{eqnarray*}\n",
    "H(t) &&= 99\\text{th percentile of asset prices from simulations at time t}\\\\\n",
    "L(t) &&= 1\\text{st percentile of asset prices from simulations at time t}\n",
    "\\end{eqnarray*}\n",
    "\n",
    "The range in the middle of the higher and lower limits is evenly distributed to each decision variable. Then $p_i$ can be defined as follows:\n",
    "\\begin{eqnarray*}\n",
    "width(t) &&= (H(t)-L(t))/Bins(t)\\\\\n",
    "p_0 &&= 0\\\\\n",
    "p_i &&= L(t)+i\\times width(t) \\quad i = 1,2\\cdots Bins(t)\\\\\n",
    "p_{Bins(t)+1} &&= +\\infty\\\\\n",
    "\\end{eqnarray*}\n",
    "\n",
    "In this way, we have made clear all about decision variables.\n",
    "\n",
    "Then we can get the optimization objectives and all constraints of our hedging strategy, the optimization problem can be expressed as:\n",
    "\\begin{eqnarray*}\n",
    "\\max &&[\\frac{1}{M}\\sum_{i=1}^{M}(V_i(T)-c_i(T))]\\\\\n",
    "    && s.t.\\\\\n",
    "V(0-) &&= c_0\\\\\n",
    "V(0+) &&= x_i(0)S(0)+[V(0-)-x_i(0)S(0)-gS(0)|x_i(0)|]\\\\\n",
    "&&...\\\\\n",
    "V(t-) &&= x_i(t-dt)S(t)+[V((t-dt)+)-x_i(t-dt)S(t-dt)]e^{rdt}\\\\\n",
    "V(t+) &&= x_i(t)S(t)+[V(t-)-x_i(t)S(t)-gS(t)|x_i(t)-x_i(t-dt)|]\\\\\n",
    "&&...\\\\\n",
    "V(T)  &&= x_i(T-dt)S(T)+[V((T-dt)+)-x_i(T-dt)S(T-dt)]e^{rdt}\n",
    "\\end{eqnarray*}\n",
    "\n",
    "Where $x_i(t)$ is the corresponding decision variable at the specific time and the specific simulation. Its determination method is just as we described above, and there is no need to repeat it.\n",
    "\n",
    "This is a nonlinear program and can take a significant amount of time to solve when the amount of data is large. If the optimization problem can still be  computational, we directly solve it. Once it exceeds our computing power, RHC comes in handy."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## An example on RHC&SP hedging\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import scipy.stats as stats\n",
    "from math import log,sqrt,exp\n",
    "np.random.seed(3333333)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the most basic case, our underlying asset follows geometric Brownian motion and thus behaves as:\n",
    "$$\n",
    "dS(t) = \\mu S(t) dt+ \\sigma S(t) d W_t\n",
    "$$\n",
    "where\n",
    "\n",
    "- $\\mu$: (constant) expected return \n",
    "- $\\sigma$: (constant) volatility \n",
    "- $W_t$: standard Brownian motion\n",
    "\n",
    "Note that $S_t$ has the closed form expression\n",
    "\n",
    "$$\n",
    "S_t = S_0 e^{\\left(\\mu - \\frac{\\sigma^2}2 \\right) t+ \\sigma W_t}\n",
    "$$\n",
    "So we can simulate the GBM of our underlying asset as follows:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>0</th>\n",
       "      <th>1</th>\n",
       "      <th>2</th>\n",
       "      <th>3</th>\n",
       "      <th>4</th>\n",
       "      <th>5</th>\n",
       "      <th>6</th>\n",
       "      <th>7</th>\n",
       "      <th>8</th>\n",
       "      <th>9</th>\n",
       "      <th>...</th>\n",
       "      <th>91</th>\n",
       "      <th>92</th>\n",
       "      <th>93</th>\n",
       "      <th>94</th>\n",
       "      <th>95</th>\n",
       "      <th>96</th>\n",
       "      <th>97</th>\n",
       "      <th>98</th>\n",
       "      <th>99</th>\n",
       "      <th>100</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>100</td>\n",
       "      <td>101.405384</td>\n",
       "      <td>100.178337</td>\n",
       "      <td>103.616873</td>\n",
       "      <td>106.228693</td>\n",
       "      <td>105.585788</td>\n",
       "      <td>107.255558</td>\n",
       "      <td>107.600233</td>\n",
       "      <td>110.543478</td>\n",
       "      <td>112.757931</td>\n",
       "      <td>...</td>\n",
       "      <td>120.637677</td>\n",
       "      <td>118.339067</td>\n",
       "      <td>120.950806</td>\n",
       "      <td>118.882438</td>\n",
       "      <td>119.627263</td>\n",
       "      <td>120.044973</td>\n",
       "      <td>122.483505</td>\n",
       "      <td>123.261533</td>\n",
       "      <td>124.891371</td>\n",
       "      <td>124.387177</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>100</td>\n",
       "      <td>98.663444</td>\n",
       "      <td>98.919356</td>\n",
       "      <td>96.565446</td>\n",
       "      <td>94.504943</td>\n",
       "      <td>96.050160</td>\n",
       "      <td>95.707867</td>\n",
       "      <td>95.571594</td>\n",
       "      <td>95.072128</td>\n",
       "      <td>97.121557</td>\n",
       "      <td>...</td>\n",
       "      <td>104.261543</td>\n",
       "      <td>103.796591</td>\n",
       "      <td>101.933913</td>\n",
       "      <td>102.783674</td>\n",
       "      <td>102.327074</td>\n",
       "      <td>102.708939</td>\n",
       "      <td>102.099863</td>\n",
       "      <td>101.690618</td>\n",
       "      <td>101.521802</td>\n",
       "      <td>101.083208</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>100</td>\n",
       "      <td>101.195996</td>\n",
       "      <td>103.119683</td>\n",
       "      <td>103.862361</td>\n",
       "      <td>107.111456</td>\n",
       "      <td>106.549582</td>\n",
       "      <td>107.028478</td>\n",
       "      <td>107.778699</td>\n",
       "      <td>107.273154</td>\n",
       "      <td>106.133063</td>\n",
       "      <td>...</td>\n",
       "      <td>96.978299</td>\n",
       "      <td>97.417939</td>\n",
       "      <td>98.502059</td>\n",
       "      <td>98.263643</td>\n",
       "      <td>98.392650</td>\n",
       "      <td>98.176275</td>\n",
       "      <td>95.971568</td>\n",
       "      <td>96.049154</td>\n",
       "      <td>95.576308</td>\n",
       "      <td>95.134793</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>100</td>\n",
       "      <td>101.022373</td>\n",
       "      <td>101.603626</td>\n",
       "      <td>100.149910</td>\n",
       "      <td>99.398529</td>\n",
       "      <td>98.720151</td>\n",
       "      <td>99.646943</td>\n",
       "      <td>99.820806</td>\n",
       "      <td>102.380946</td>\n",
       "      <td>102.092217</td>\n",
       "      <td>...</td>\n",
       "      <td>96.044015</td>\n",
       "      <td>95.308620</td>\n",
       "      <td>95.491278</td>\n",
       "      <td>95.260777</td>\n",
       "      <td>95.165658</td>\n",
       "      <td>94.827381</td>\n",
       "      <td>95.715683</td>\n",
       "      <td>93.646837</td>\n",
       "      <td>94.991555</td>\n",
       "      <td>95.720995</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>100</td>\n",
       "      <td>99.083501</td>\n",
       "      <td>100.240481</td>\n",
       "      <td>100.577953</td>\n",
       "      <td>100.205828</td>\n",
       "      <td>100.335359</td>\n",
       "      <td>103.112172</td>\n",
       "      <td>103.311523</td>\n",
       "      <td>103.034164</td>\n",
       "      <td>103.865589</td>\n",
       "      <td>...</td>\n",
       "      <td>102.801787</td>\n",
       "      <td>101.738336</td>\n",
       "      <td>99.846013</td>\n",
       "      <td>96.690299</td>\n",
       "      <td>97.922116</td>\n",
       "      <td>97.431947</td>\n",
       "      <td>98.021177</td>\n",
       "      <td>98.848243</td>\n",
       "      <td>98.729978</td>\n",
       "      <td>97.674446</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>295</th>\n",
       "      <td>100</td>\n",
       "      <td>98.947831</td>\n",
       "      <td>99.844767</td>\n",
       "      <td>101.793332</td>\n",
       "      <td>100.960163</td>\n",
       "      <td>99.251986</td>\n",
       "      <td>98.203732</td>\n",
       "      <td>99.523928</td>\n",
       "      <td>99.584420</td>\n",
       "      <td>98.834245</td>\n",
       "      <td>...</td>\n",
       "      <td>102.705188</td>\n",
       "      <td>104.905659</td>\n",
       "      <td>105.248579</td>\n",
       "      <td>105.344766</td>\n",
       "      <td>106.222066</td>\n",
       "      <td>105.808412</td>\n",
       "      <td>106.689756</td>\n",
       "      <td>105.771740</td>\n",
       "      <td>105.137627</td>\n",
       "      <td>105.783174</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>296</th>\n",
       "      <td>100</td>\n",
       "      <td>102.552449</td>\n",
       "      <td>102.417644</td>\n",
       "      <td>102.611649</td>\n",
       "      <td>102.915857</td>\n",
       "      <td>103.468866</td>\n",
       "      <td>103.682519</td>\n",
       "      <td>101.696423</td>\n",
       "      <td>101.897650</td>\n",
       "      <td>100.372853</td>\n",
       "      <td>...</td>\n",
       "      <td>116.327460</td>\n",
       "      <td>116.997676</td>\n",
       "      <td>115.922214</td>\n",
       "      <td>115.553568</td>\n",
       "      <td>116.076033</td>\n",
       "      <td>116.210391</td>\n",
       "      <td>117.062126</td>\n",
       "      <td>117.996005</td>\n",
       "      <td>118.523830</td>\n",
       "      <td>118.847782</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>297</th>\n",
       "      <td>100</td>\n",
       "      <td>101.106308</td>\n",
       "      <td>102.223835</td>\n",
       "      <td>102.282409</td>\n",
       "      <td>103.955360</td>\n",
       "      <td>104.486539</td>\n",
       "      <td>103.020099</td>\n",
       "      <td>101.981872</td>\n",
       "      <td>102.566668</td>\n",
       "      <td>103.895962</td>\n",
       "      <td>...</td>\n",
       "      <td>111.546030</td>\n",
       "      <td>111.972045</td>\n",
       "      <td>113.432689</td>\n",
       "      <td>113.640900</td>\n",
       "      <td>111.712173</td>\n",
       "      <td>111.399928</td>\n",
       "      <td>108.362561</td>\n",
       "      <td>106.522629</td>\n",
       "      <td>107.214850</td>\n",
       "      <td>107.263977</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>298</th>\n",
       "      <td>100</td>\n",
       "      <td>100.468105</td>\n",
       "      <td>98.665958</td>\n",
       "      <td>96.887717</td>\n",
       "      <td>96.410848</td>\n",
       "      <td>98.198899</td>\n",
       "      <td>96.366456</td>\n",
       "      <td>96.276205</td>\n",
       "      <td>96.299949</td>\n",
       "      <td>95.652335</td>\n",
       "      <td>...</td>\n",
       "      <td>83.558432</td>\n",
       "      <td>84.146787</td>\n",
       "      <td>84.253111</td>\n",
       "      <td>84.951584</td>\n",
       "      <td>84.820157</td>\n",
       "      <td>84.820120</td>\n",
       "      <td>85.611540</td>\n",
       "      <td>85.730221</td>\n",
       "      <td>83.483584</td>\n",
       "      <td>83.330518</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>299</th>\n",
       "      <td>100</td>\n",
       "      <td>100.603336</td>\n",
       "      <td>102.238185</td>\n",
       "      <td>102.424185</td>\n",
       "      <td>103.066117</td>\n",
       "      <td>102.588991</td>\n",
       "      <td>104.367026</td>\n",
       "      <td>106.255735</td>\n",
       "      <td>106.496528</td>\n",
       "      <td>106.633448</td>\n",
       "      <td>...</td>\n",
       "      <td>86.159028</td>\n",
       "      <td>86.770479</td>\n",
       "      <td>86.819395</td>\n",
       "      <td>87.296287</td>\n",
       "      <td>88.249483</td>\n",
       "      <td>88.814440</td>\n",
       "      <td>90.094591</td>\n",
       "      <td>90.157996</td>\n",
       "      <td>90.554745</td>\n",
       "      <td>90.090323</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>300 rows × 101 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "     0           1           2           3           4           5    \\\n",
       "0    100  101.405384  100.178337  103.616873  106.228693  105.585788   \n",
       "1    100   98.663444   98.919356   96.565446   94.504943   96.050160   \n",
       "2    100  101.195996  103.119683  103.862361  107.111456  106.549582   \n",
       "3    100  101.022373  101.603626  100.149910   99.398529   98.720151   \n",
       "4    100   99.083501  100.240481  100.577953  100.205828  100.335359   \n",
       "..   ...         ...         ...         ...         ...         ...   \n",
       "295  100   98.947831   99.844767  101.793332  100.960163   99.251986   \n",
       "296  100  102.552449  102.417644  102.611649  102.915857  103.468866   \n",
       "297  100  101.106308  102.223835  102.282409  103.955360  104.486539   \n",
       "298  100  100.468105   98.665958   96.887717   96.410848   98.198899   \n",
       "299  100  100.603336  102.238185  102.424185  103.066117  102.588991   \n",
       "\n",
       "            6           7           8           9    ...         91   \\\n",
       "0    107.255558  107.600233  110.543478  112.757931  ...  120.637677   \n",
       "1     95.707867   95.571594   95.072128   97.121557  ...  104.261543   \n",
       "2    107.028478  107.778699  107.273154  106.133063  ...   96.978299   \n",
       "3     99.646943   99.820806  102.380946  102.092217  ...   96.044015   \n",
       "4    103.112172  103.311523  103.034164  103.865589  ...  102.801787   \n",
       "..          ...         ...         ...         ...  ...         ...   \n",
       "295   98.203732   99.523928   99.584420   98.834245  ...  102.705188   \n",
       "296  103.682519  101.696423  101.897650  100.372853  ...  116.327460   \n",
       "297  103.020099  101.981872  102.566668  103.895962  ...  111.546030   \n",
       "298   96.366456   96.276205   96.299949   95.652335  ...   83.558432   \n",
       "299  104.367026  106.255735  106.496528  106.633448  ...   86.159028   \n",
       "\n",
       "            92          93          94          95          96          97   \\\n",
       "0    118.339067  120.950806  118.882438  119.627263  120.044973  122.483505   \n",
       "1    103.796591  101.933913  102.783674  102.327074  102.708939  102.099863   \n",
       "2     97.417939   98.502059   98.263643   98.392650   98.176275   95.971568   \n",
       "3     95.308620   95.491278   95.260777   95.165658   94.827381   95.715683   \n",
       "4    101.738336   99.846013   96.690299   97.922116   97.431947   98.021177   \n",
       "..          ...         ...         ...         ...         ...         ...   \n",
       "295  104.905659  105.248579  105.344766  106.222066  105.808412  106.689756   \n",
       "296  116.997676  115.922214  115.553568  116.076033  116.210391  117.062126   \n",
       "297  111.972045  113.432689  113.640900  111.712173  111.399928  108.362561   \n",
       "298   84.146787   84.253111   84.951584   84.820157   84.820120   85.611540   \n",
       "299   86.770479   86.819395   87.296287   88.249483   88.814440   90.094591   \n",
       "\n",
       "            98          99          100  \n",
       "0    123.261533  124.891371  124.387177  \n",
       "1    101.690618  101.521802  101.083208  \n",
       "2     96.049154   95.576308   95.134793  \n",
       "3     93.646837   94.991555   95.720995  \n",
       "4     98.848243   98.729978   97.674446  \n",
       "..          ...         ...         ...  \n",
       "295  105.771740  105.137627  105.783174  \n",
       "296  117.996005  118.523830  118.847782  \n",
       "297  106.522629  107.214850  107.263977  \n",
       "298   85.730221   83.483584   83.330518  \n",
       "299   90.157996   90.554745   90.090323  \n",
       "\n",
       "[300 rows x 101 columns]"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Simulation of GBM\n",
    "#dSt/St = mu dt + sigma dBt\n",
    "def GBM(mu,sigma,S0,Tfin,NSim = 300):\n",
    "     NSteps = 100\n",
    "     B = pd.DataFrame(index = [k for k in range(NSim)]\\\n",
    "                 ,columns = [k for k in range(NSteps+1)])\n",
    "     B = B.fillna(0)\n",
    "     S = pd.DataFrame(index = [k for k in range(NSim)]\\\n",
    "                 ,columns = [k for k in range(NSteps+1)])\n",
    "     S = S.fillna(0)\n",
    "     S[0] = pd.Series([S0]*NSim)\n",
    "\n",
    "     for i in range(NSteps):\n",
    "          dB = pd.Series(np.random.randn(1,NSim)[0])\n",
    "          dB = dB-dB.mean()\n",
    "          dB = dB/dB.std()\n",
    "          dB = sqrt(Tfin/NSteps)*dB\n",
    "          B[i+1] = B[i] + dB\n",
    "\n",
    "          t = (Tfin/NSteps)*(i+1)\n",
    "          S[i+1] = B[i+1].apply(lambda x: S0*exp((mu-sigma*sigma/2)*t +sigma*x))\n",
    "     return S\n",
    "\n",
    "GBM(0.15,0.25,100,1/4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For preparations, we provide the code of Black-Scholes formula in advance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "#The Black-Scholes formula\n",
    "def bs_call(s,K,sigma,t,r=0,d=0):\n",
    "     d1 = (log(s/K)+(r-d)*t)/(sigma*sqrt(t)) + sigma*sqrt(t)/2\n",
    "     d2 = d1 - sigma*sqrt(t)\n",
    "\n",
    "     c = s*exp(-d*t)*stats.norm.cdf(d1) - K*exp(-r*t)*stats.norm.cdf(d2)\n",
    "     delta = exp(-d*t)*stats.norm.cdf(d1)\n",
    "     Gam = stats.norm.pdf(d1)/s/sigma/sqrt(t)\n",
    "\n",
    "     return pd.Series({'c':c,'delta':delta,'Gam':Gam})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Besides, we need to define a function that can return a distribution of the price range, given the number of decision variables and the results of the Monte Carlo simulations. Note that Bins[t] is the number of decision variables at time t."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[(0, 90.9215878431816), (90.9215878431816, 97.62528534239404), (97.62528534239404, 104.32898284160646), (104.32898284160646, 111.0326803408189), (111.0326803408189, inf)]\n",
      "[(0, 97.13954167204612), (97.13954167204612, 113.86126947372068), (113.86126947372068, inf)]\n"
     ]
    }
   ],
   "source": [
    "def distribute(S,t,NSim = 300):\n",
    "     NSteps = 100\n",
    "     h = len(Bins)\n",
    "     St = S[t*(NSteps//h)]\n",
    "     St1 = list(St.sort_values())\n",
    "     L = St1[:int(NSim*0.01)][-1]\n",
    "     H = St1[:int(NSim*0.99)][-1]\n",
    "\n",
    "     bint = Bins[t]\n",
    "     width = (H-L)/bint\n",
    "\n",
    "     distribution = []\n",
    "     distribution.append((0,L+width))\n",
    "     for j in range(1,bint-1):\n",
    "          distribution.append((L+j*width,L+(j+1)*width))\n",
    "     distribution.append((L+(bint-1)*width,float('+inf')))\n",
    "\n",
    "     return distribution\n",
    "    \n",
    "Bins = [1,5,3]\n",
    "S = GBM(0.15,0.25,100,1/4)   \n",
    "print(distribute(S,1))\n",
    "print(distribute(S,2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, let's set up some basic numbers and start a model.\n",
    "\n",
    "Here, we choose [1 5 3] as our Bins which means that there are three rebalancing points before expiration and the number of decision variables at each rebalancing point are 1,5 and 3. As the same time, we set the number of samples as 300, which means the number of Monte Carlo simulation paths of the underlying asset is 300."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "Bins = [1,5,3]\n",
    "h = len(Bins)\n",
    "mu = 0.15\n",
    "sigma = 0.5 #we set a relatively large volatility\n",
    "S0 = 100\n",
    "K = 100\n",
    "T = 3/24 #one and a half months, we adjust V(t) every half a month\n",
    "r = 0.03\n",
    "g = 0.005\n",
    "NSim = 300"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Restricted license - for non-production use only - expires 2022-01-13\n"
     ]
    }
   ],
   "source": [
    "from gurobipy import *\n",
    "\n",
    "sp_model = Model('Stochastic Programming')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's start by adding variables to the optimization model. The variables we need to add include all the decision variables corresponding  to the elements in Bins and the value of hedging portfolio at each rebalancing point. It should be noted that we need to distinguish the value V (T -) before trade is made from the value $V (T +)$ after the trade is made, but since $V (0 -)$ is fixed as the B-S value of the call at time 0, we don't have to take it as a variable.\n",
    "\n",
    "Here is another point to note. Technically, we need to set the difference between the decision variables on two adjacent rebalancing points and their absolute values as new variables. Then we add \"absolute value constraints\" between them. This is because of the syntax limitations of module gurobipy, but the basic idea has not changed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "S = GBM(mu,sigma,S0,T,NSim=NSim)#Regenerate S\n",
    "\n",
    "def target():\n",
    "    money_list = [Vit[i,Vnum-1]-max((S[100][i]-K),0) for i in range(NSim)]\n",
    "    return sum(money_list)/NSim\n",
    "\n",
    "\n",
    "#set variables: Vi(0+),Vi(1-),Vi(1+)......Vi(t-),Vi(t+)......Vi(T)\n",
    "Vnum = 2 * len(Bins) # The total number of Vi(t)\n",
    "Vit={}\n",
    "for i in range(NSim): \n",
    "    for j in range(Vnum):\n",
    "        Vit[i,j] = sp_model.addVar(lb = 0,ub=GRB.INFINITY, vtype = GRB.CONTINUOUS, name = 'V_' + str(i)  +'_'+ str(j))\n",
    "\n",
    "#set variables: x\n",
    "x = {} \n",
    "for i in range(len(Bins)): \n",
    "    for j in range(Bins[i]):\n",
    "        x[i,j] = sp_model.addVar(lb = 0,ub=GRB.INFINITY, vtype = GRB.CONTINUOUS, name = 'delta_' + str(i)  +'_'+ str(j))\n",
    "\n",
    "#We need some additional variables to express abs_ of other variables.\n",
    "#We will set the abs_ constraints later.\n",
    "x_abs = {}#abs(x-y)\n",
    "x_diff = {}#(x-y)\n",
    "for i in range(len(Bins)-1):\n",
    "    for j in range(Bins[i]):\n",
    "        for k in range(Bins[i+1]):\n",
    "            x_abs[i,j,k] = sp_model.addVar(lb = 0,ub=GRB.INFINITY, vtype = GRB.CONTINUOUS, name = 'abs_'+str(i)+'_'+str(j))\n",
    "            x_diff[i,j,k] = sp_model.addVar(lb = 0,ub=GRB.INFINITY, vtype = GRB.CONTINUOUS, name = 'diff_'+str(i)+'_'+str(j))\n",
    "            \n",
    "sp_model.setObjective(target(),GRB.MAXIMIZE)\n",
    "\n",
    "#set the abs_ constraints\n",
    "for i in range(len(Bins)-1):\n",
    "    for j in range(Bins[i]):\n",
    "        for k in range(Bins[i+1]):\n",
    "            sp_model.addConstr(x_diff[i,j,k]==\\\n",
    "                               x[i,j]-x[i+1,k],name = 'diff_cons'+str(i)+'_'+str(j)+'_'+str(k))\n",
    "            sp_model.addConstr(x_abs[i,j,k]==\\\n",
    "                               abs_(x_diff[i,j,k]),name = 'abs_cons'+str(i)+'_'+str(j)+'_'+str(k))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then we add the constraints of optimization. In fact, it is just the general process of dynamic hedging we have introduced earlier. Here, we determine $\\Delta(t)$ according to the results of each Monte Carlo simulation and the corresponding decision variables. Once we have done all of these, the module of gurobipy will help us to find the optimal decision variables."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Set control conditions\n",
    "\n",
    "#get the distribution\n",
    "distribution1 = distribute(S,1)\n",
    "distribution2 = distribute(S,2)\n",
    "\n",
    "#define a decision function\n",
    "def choose(price,t):\n",
    "    distribution = distribution1 if t == 1 else distribution2\n",
    "    for i in range(Bins[t]):\n",
    "        if distribution[i][0]<price and distribution[i][1]>=price:\n",
    "            return i\n",
    "\n",
    "c0 = bs_call(S0,K,sigma,T,r=0.03)['c']\n",
    "\n",
    "for i in range(NSim):#300 simulations\n",
    "    #the decision index\n",
    "    index1 = choose(S[33][i],1)\n",
    "    index2 = choose(S[66][i],2)\n",
    "    \n",
    "    #control condition at time 0\n",
    "    sp_model.addConstr(Vit[i,0]==x[0,0]*S[0][i]+(c0-x[0,0]*S[0][i]\\\n",
    "            -g*x[0,0]*S[0][i]),name = 'cons_'+str(i)+'_'+str(0))\n",
    "\n",
    "    #control conditions at time 1\n",
    "    sp_model.addConstr(Vit[i,1]==x[0,0]*S[33][i]+(c0-x[0,0]*S[0][i]\\\n",
    "            -g*x[0,0]*S[0][i])*exp(T*r*33/100),name = 'cons_'+str(i)+'_'+str(1))\n",
    "    sp_model.addConstr(Vit[i,2]==x[1,index1]*S[33][i] +(Vit[i,1]\\\n",
    "            -x[1,index1]*S[33][i]-g*S[33][i]*x_abs[0,0,index1]),name = 'cons_'+str(i)+'_'+str(2))\n",
    "\n",
    "    #control conditions at time 2\n",
    "    sp_model.addConstr(Vit[i,3]==x[1,index1]*S[66][i] +(Vit[i,1]\\\n",
    "            -x[1,index1]*S[33][i]-g*S[33][i]*x_abs[0,0,index1])*exp(T*r*33/100),name = 'cons_'+str(i)+'_'+str(3))\n",
    "    sp_model.addConstr(Vit[i,4]==x[2,index2]*S[66][i] +(Vit[i,3]\\\n",
    "            -x[2,index2]*S[66][i]-g*S[66][i]*x_abs[1,index1,index2]) ,name = 'cons_'+str(i)+'_'+str(4))\n",
    "\n",
    "    #control condition at time 3\n",
    "    sp_model.addConstr(Vit[i,5]==x[2,index2]*S[100][i] +(Vit[i,3]\\\n",
    "             -x[2,index2]*S[66][i]-g*S[66][i]*x_abs[1,index1,index2])*exp(T*r*34/100),name = 'cons_'+str(i)+'_'+str(5))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (win64)\n",
      "Thread count: 6 physical cores, 12 logical processors, using up to 12 threads\n",
      "Optimize a model with 1820 rows, 1849 columns and 5460 nonzeros\n",
      "Model fingerprint: 0x0212f7c9\n",
      "Model has 20 general constraints\n",
      "Variable types: 1849 continuous, 0 integer (0 binary)\n",
      "Coefficient statistics:\n",
      "  Matrix range     [2e-03, 4e+01]\n",
      "  Objective range  [3e-03, 3e-03]\n",
      "  Bounds range     [0e+00, 0e+00]\n",
      "  RHS range        [7e+00, 7e+00]\n",
      "Presolve removed 1794 rows and 1839 columns\n",
      "Presolve time: 0.02s\n",
      "Presolved: 26 rows, 10 columns, 65 nonzeros\n",
      "Variable types: 10 continuous, 0 integer (0 binary)\n",
      "\n",
      "Root relaxation: objective -8.918168e-01, 11 iterations, 0.00 seconds\n",
      "\n",
      "    Nodes    |    Current Node    |     Objective Bounds      |     Work\n",
      " Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time\n",
      "\n",
      "*    0     0               0      -0.8918168   -0.89182  0.00%     -    0s\n",
      "\n",
      "Explored 0 nodes (11 simplex iterations) in 0.05 seconds\n",
      "Thread count was 12 (of 12 available processors)\n",
      "\n",
      "Solution count 1: -0.891817 \n",
      "No other solutions better than -0.891817\n",
      "\n",
      "Optimal solution found (tolerance 1.00e-04)\n",
      "Best objective -8.918168365797e-01, best bound -8.918168365797e-01, gap 0.0000%\n"
     ]
    }
   ],
   "source": [
    "sp_model.optimize()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now let's have a look at the optimization results. Let's observe the minimum hedge error and the optimal parameters respectively."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "the hege error is 0.8918168365796761, while it is 9.329017567858573 when hedging is not performed.\n"
     ]
    }
   ],
   "source": [
    "non_hedging_error = sum([abs(c0*exp(0.03)-max(S[100][i]-K,0)) for i in range(300)])/300\n",
    "RHC_SP_hedge_error = sp_model.getJSONSolution()[sp_model.getJSONSolution().find(\"ObjVal\")+10:\\\n",
    "                                                sp_model.getJSONSolution().find(\"ObjBound\")-4]\n",
    "RHC_SP_hedge_error = abs(float(RHC_SP_hedge_error))\n",
    "print('the hege error is '+ str(RHC_SP_hedge_error)+', while it is '+\\\n",
    "     str(non_hedging_error)+' when hedging is not performed.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{(0, 0): 0.23045680181992487,\n",
       " (1, 0): 0.23045680181992492,\n",
       " (1, 1): 0.23045680181992487,\n",
       " (1, 2): 0.23045680181992487,\n",
       " (1, 3): 0.23045680181992487,\n",
       " (1, 4): 0.23045680181992487,\n",
       " (2, 0): 0.0851558316768965,\n",
       " (2, 1): 0.23045680181992487,\n",
       " (2, 2): 0.23045680181992492}"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "optimal_parameters = {}\n",
    "for key in x.keys():\n",
    "    optimal_parameters[key] = x[key].x\n",
    "optimal_parameters"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As we can see, many of these optimal decision variables are the same. Even if there is a difference, the difference is small. But this is not surprising, because our hedging process takes into account the transaction costs. In many cases, it may be better not to change or less change the holding of the underlying asset. If we make T larger, the difference of optimal variables will increase, and even each decision variable may be different. But that means we need to add more rebalancing points to adapt to the longer time, otherwise, the performance will become worse."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Back test with these optimal parameters"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, we have to do a very important step, that is to retest the optimal decision variables we obtained as fixed parameters. In this process, we cannot use the underlying asset prices which is previously used to output these parameters, otherwise our back test will be meaningless. If we do that, there is no doubt that our hedging strategy will surpass everything, but it is a kind of cheating, which is equivalent to predicting the future. It is precisely because the future is unpredictable that we designed a hedging strategy, otherwise I would simply quit my job to buy lottery tickets.\n",
    "\n",
    "We regenerate the prices of the underlying asset, then simulate the transaction according to the process described earlier. In order to have a clearer observation, we record the portfolio value at each time point, and then plot them into a curve."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "simulating the hedging process\n",
      "done!\n"
     ]
    }
   ],
   "source": [
    "#Regenerate S\n",
    "S = GBM(mu,sigma,S0,T)\n",
    "\n",
    "#set two dataframe to record the hedging portfolio value and the portfolio value at each time.\n",
    "#As we are considering a hedging process with transaction costs, V(t-) and V(t+) may not be the same number.\n",
    "#For simplicity, we use the value before the trade is made.\n",
    "values = pd.DataFrame(index = [k for k in range(NSim)]\\\n",
    "                 ,columns = [k for k in range(100+1)])\n",
    "V_values = pd.DataFrame(index = [k for k in range(NSim)]\\\n",
    "                 ,columns = [k for k in range(100+1)])\n",
    "c0 = bs_call(S0,K,sigma,T,r=0.03)['c']\n",
    "values[0] = pd.Series([0]*NSim)\n",
    "V_values[0] = pd.Series([c0]*NSim)\n",
    "\n",
    "\n",
    "#perform the hedging with constant parameters.\n",
    "print('simulating the hedging process')\n",
    "for i in range(NSim):\n",
    "    #the decision index\n",
    "    index1 = choose(S[33][i],1)\n",
    "    index2 = choose(S[66][i],2)\n",
    "    \n",
    "    \n",
    "    #the hedging process\n",
    "    shares = 0\n",
    "    money = c0\n",
    "    for step in range(100+1):\n",
    "           \n",
    "        \n",
    "        if step == 0:#trade is made\n",
    "            shares = optimal_parameters[0,0]\n",
    "            money = c0 - S[0][i]*shares - shares*S[0][i]*g\n",
    "            \n",
    "        elif step > 0 and step < 33:\n",
    "            money = money*exp(r*T/100)\n",
    "            V_values[step][i] = money+shares*S[step][i]\n",
    "            values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            \n",
    "        elif step == 33:#trade is made\n",
    "            money = money*exp(r*T/100)\n",
    "            V_values[step][i] = money+shares*S[step][i]\n",
    "            values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            #trade\n",
    "            pre_shares = shares\n",
    "            pre_v_value = money+shares*S[step][i]\n",
    "            shares = optimal_parameters[1,index1]\n",
    "            money = pre_v_value - S[step][i]*shares -g*S[step][i]*abs(shares-pre_shares)\n",
    "            \n",
    "        elif step > 33 and step < 66:\n",
    "            money = money*exp(r*T/100)\n",
    "            V_values[step][i] = money+shares*S[step][i]\n",
    "            values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            \n",
    "        elif step == 66:#trade is made\n",
    "            money = money*exp(r*T/100)\n",
    "            V_values[step][i] = money+shares*S[step][i]\n",
    "            values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            #trade\n",
    "            pre_shares = shares\n",
    "            pre_v_value = money+shares*S[step][i]\n",
    "            shares = optimal_parameters[2,index2]\n",
    "            money = pre_v_value - S[step][i]*shares -g*S[step][i]*abs(shares-pre_shares)\n",
    "            \n",
    "        elif step >66 and step != 100:\n",
    "            money = money*exp(r*T/100)\n",
    "            V_values[step][i] = money+shares*S[step][i]\n",
    "            values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            \n",
    "        else:\n",
    "            money = money*exp(r*T/100)\n",
    "            V_values[step][i] = money+shares*S[step][i]\n",
    "            values[step][i] = money+shares*S[step][i]-max(S[step][i]-K,0)\n",
    "                      \n",
    "print('done!')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>0</th>\n",
       "      <th>1</th>\n",
       "      <th>2</th>\n",
       "      <th>3</th>\n",
       "      <th>4</th>\n",
       "      <th>5</th>\n",
       "      <th>6</th>\n",
       "      <th>7</th>\n",
       "      <th>8</th>\n",
       "      <th>9</th>\n",
       "      <th>...</th>\n",
       "      <th>91</th>\n",
       "      <th>92</th>\n",
       "      <th>93</th>\n",
       "      <th>94</th>\n",
       "      <th>95</th>\n",
       "      <th>96</th>\n",
       "      <th>97</th>\n",
       "      <th>98</th>\n",
       "      <th>99</th>\n",
       "      <th>100</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0</td>\n",
       "      <td>-0.057027</td>\n",
       "      <td>-0.316204</td>\n",
       "      <td>0.077678</td>\n",
       "      <td>0.893646</td>\n",
       "      <td>1.043802</td>\n",
       "      <td>0.378602</td>\n",
       "      <td>1.029554</td>\n",
       "      <td>0.419916</td>\n",
       "      <td>1.057062</td>\n",
       "      <td>...</td>\n",
       "      <td>5.178783</td>\n",
       "      <td>4.885266</td>\n",
       "      <td>4.105524</td>\n",
       "      <td>3.8634</td>\n",
       "      <td>3.717481</td>\n",
       "      <td>3.872979</td>\n",
       "      <td>3.323852</td>\n",
       "      <td>3.543512</td>\n",
       "      <td>2.99995</td>\n",
       "      <td>3.146823</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0</td>\n",
       "      <td>0.391769</td>\n",
       "      <td>1.091542</td>\n",
       "      <td>1.52966</td>\n",
       "      <td>1.207264</td>\n",
       "      <td>1.764104</td>\n",
       "      <td>1.868429</td>\n",
       "      <td>2.088136</td>\n",
       "      <td>2.213035</td>\n",
       "      <td>2.235718</td>\n",
       "      <td>...</td>\n",
       "      <td>4.835856</td>\n",
       "      <td>5.216681</td>\n",
       "      <td>4.907291</td>\n",
       "      <td>4.687089</td>\n",
       "      <td>4.289564</td>\n",
       "      <td>4.796074</td>\n",
       "      <td>5.063974</td>\n",
       "      <td>5.844167</td>\n",
       "      <td>6.141477</td>\n",
       "      <td>6.39985</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0</td>\n",
       "      <td>-0.071073</td>\n",
       "      <td>-0.365981</td>\n",
       "      <td>-0.72458</td>\n",
       "      <td>-0.446752</td>\n",
       "      <td>-0.372388</td>\n",
       "      <td>-0.388061</td>\n",
       "      <td>-0.09155</td>\n",
       "      <td>0.526892</td>\n",
       "      <td>0.228026</td>\n",
       "      <td>...</td>\n",
       "      <td>4.679236</td>\n",
       "      <td>4.558783</td>\n",
       "      <td>4.387732</td>\n",
       "      <td>4.363564</td>\n",
       "      <td>4.293339</td>\n",
       "      <td>4.202155</td>\n",
       "      <td>4.189941</td>\n",
       "      <td>4.238253</td>\n",
       "      <td>4.283082</td>\n",
       "      <td>4.337152</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>0</td>\n",
       "      <td>0.802834</td>\n",
       "      <td>0.532782</td>\n",
       "      <td>0.136686</td>\n",
       "      <td>-0.268971</td>\n",
       "      <td>-0.570683</td>\n",
       "      <td>-0.946389</td>\n",
       "      <td>-2.017576</td>\n",
       "      <td>-2.130781</td>\n",
       "      <td>-1.248977</td>\n",
       "      <td>...</td>\n",
       "      <td>4.01438</td>\n",
       "      <td>4.89747</td>\n",
       "      <td>4.757902</td>\n",
       "      <td>4.594794</td>\n",
       "      <td>5.106271</td>\n",
       "      <td>4.430222</td>\n",
       "      <td>4.995095</td>\n",
       "      <td>4.785386</td>\n",
       "      <td>5.685716</td>\n",
       "      <td>6.651555</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>0</td>\n",
       "      <td>-0.424658</td>\n",
       "      <td>-0.623116</td>\n",
       "      <td>-0.530347</td>\n",
       "      <td>-1.002927</td>\n",
       "      <td>-1.15566</td>\n",
       "      <td>0.145994</td>\n",
       "      <td>-0.797379</td>\n",
       "      <td>-0.51455</td>\n",
       "      <td>-0.30869</td>\n",
       "      <td>...</td>\n",
       "      <td>4.602889</td>\n",
       "      <td>4.970059</td>\n",
       "      <td>5.510216</td>\n",
       "      <td>5.708839</td>\n",
       "      <td>5.857788</td>\n",
       "      <td>5.805448</td>\n",
       "      <td>5.956107</td>\n",
       "      <td>5.814142</td>\n",
       "      <td>5.778943</td>\n",
       "      <td>6.909854</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>295</th>\n",
       "      <td>0</td>\n",
       "      <td>0.129063</td>\n",
       "      <td>0.456476</td>\n",
       "      <td>0.437475</td>\n",
       "      <td>1.270736</td>\n",
       "      <td>0.235031</td>\n",
       "      <td>0.452252</td>\n",
       "      <td>0.972755</td>\n",
       "      <td>1.142008</td>\n",
       "      <td>1.301067</td>\n",
       "      <td>...</td>\n",
       "      <td>5.346941</td>\n",
       "      <td>5.274122</td>\n",
       "      <td>5.343785</td>\n",
       "      <td>5.474327</td>\n",
       "      <td>5.261981</td>\n",
       "      <td>5.325353</td>\n",
       "      <td>5.212335</td>\n",
       "      <td>5.204316</td>\n",
       "      <td>5.07139</td>\n",
       "      <td>5.047292</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>296</th>\n",
       "      <td>0</td>\n",
       "      <td>0.488278</td>\n",
       "      <td>0.655745</td>\n",
       "      <td>1.031191</td>\n",
       "      <td>1.252027</td>\n",
       "      <td>1.088541</td>\n",
       "      <td>1.713402</td>\n",
       "      <td>1.733892</td>\n",
       "      <td>1.798113</td>\n",
       "      <td>1.873411</td>\n",
       "      <td>...</td>\n",
       "      <td>5.171382</td>\n",
       "      <td>4.808807</td>\n",
       "      <td>4.947419</td>\n",
       "      <td>4.987899</td>\n",
       "      <td>4.597781</td>\n",
       "      <td>4.264246</td>\n",
       "      <td>4.327928</td>\n",
       "      <td>2.695227</td>\n",
       "      <td>5.597434</td>\n",
       "      <td>5.83875</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>297</th>\n",
       "      <td>0</td>\n",
       "      <td>0.636345</td>\n",
       "      <td>0.785896</td>\n",
       "      <td>0.878348</td>\n",
       "      <td>1.02283</td>\n",
       "      <td>0.867989</td>\n",
       "      <td>0.97976</td>\n",
       "      <td>1.557438</td>\n",
       "      <td>1.252998</td>\n",
       "      <td>1.305088</td>\n",
       "      <td>...</td>\n",
       "      <td>4.969113</td>\n",
       "      <td>5.341223</td>\n",
       "      <td>5.259682</td>\n",
       "      <td>5.020607</td>\n",
       "      <td>3.92121</td>\n",
       "      <td>4.738337</td>\n",
       "      <td>5.860248</td>\n",
       "      <td>5.770157</td>\n",
       "      <td>5.132601</td>\n",
       "      <td>5.633844</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>298</th>\n",
       "      <td>0</td>\n",
       "      <td>-0.020627</td>\n",
       "      <td>0.457591</td>\n",
       "      <td>0.417465</td>\n",
       "      <td>0.919524</td>\n",
       "      <td>0.798985</td>\n",
       "      <td>0.789552</td>\n",
       "      <td>1.039093</td>\n",
       "      <td>1.210106</td>\n",
       "      <td>0.966492</td>\n",
       "      <td>...</td>\n",
       "      <td>-15.539719</td>\n",
       "      <td>-16.372139</td>\n",
       "      <td>-17.850698</td>\n",
       "      <td>-17.215457</td>\n",
       "      <td>-16.700505</td>\n",
       "      <td>-17.679726</td>\n",
       "      <td>-19.059941</td>\n",
       "      <td>-19.580849</td>\n",
       "      <td>-21.198402</td>\n",
       "      <td>-23.35044</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>299</th>\n",
       "      <td>0</td>\n",
       "      <td>-0.475465</td>\n",
       "      <td>-0.162466</td>\n",
       "      <td>0.555595</td>\n",
       "      <td>-0.617583</td>\n",
       "      <td>0.093245</td>\n",
       "      <td>0.204948</td>\n",
       "      <td>-1.176273</td>\n",
       "      <td>-0.141477</td>\n",
       "      <td>-0.725119</td>\n",
       "      <td>...</td>\n",
       "      <td>4.250022</td>\n",
       "      <td>3.147839</td>\n",
       "      <td>0.455908</td>\n",
       "      <td>-0.021995</td>\n",
       "      <td>0.591024</td>\n",
       "      <td>0.563701</td>\n",
       "      <td>-2.273026</td>\n",
       "      <td>-2.617442</td>\n",
       "      <td>-1.339127</td>\n",
       "      <td>-0.502456</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>300 rows × 101 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "     0         1         2         3         4         5         6    \\\n",
       "0      0 -0.057027 -0.316204  0.077678  0.893646  1.043802  0.378602   \n",
       "1      0  0.391769  1.091542   1.52966  1.207264  1.764104  1.868429   \n",
       "2      0 -0.071073 -0.365981  -0.72458 -0.446752 -0.372388 -0.388061   \n",
       "3      0  0.802834  0.532782  0.136686 -0.268971 -0.570683 -0.946389   \n",
       "4      0 -0.424658 -0.623116 -0.530347 -1.002927  -1.15566  0.145994   \n",
       "..   ...       ...       ...       ...       ...       ...       ...   \n",
       "295    0  0.129063  0.456476  0.437475  1.270736  0.235031  0.452252   \n",
       "296    0  0.488278  0.655745  1.031191  1.252027  1.088541  1.713402   \n",
       "297    0  0.636345  0.785896  0.878348   1.02283  0.867989   0.97976   \n",
       "298    0 -0.020627  0.457591  0.417465  0.919524  0.798985  0.789552   \n",
       "299    0 -0.475465 -0.162466  0.555595 -0.617583  0.093245  0.204948   \n",
       "\n",
       "          7         8         9    ...        91         92         93   \\\n",
       "0    1.029554  0.419916  1.057062  ...   5.178783   4.885266   4.105524   \n",
       "1    2.088136  2.213035  2.235718  ...   4.835856   5.216681   4.907291   \n",
       "2    -0.09155  0.526892  0.228026  ...   4.679236   4.558783   4.387732   \n",
       "3   -2.017576 -2.130781 -1.248977  ...    4.01438    4.89747   4.757902   \n",
       "4   -0.797379  -0.51455  -0.30869  ...   4.602889   4.970059   5.510216   \n",
       "..        ...       ...       ...  ...        ...        ...        ...   \n",
       "295  0.972755  1.142008  1.301067  ...   5.346941   5.274122   5.343785   \n",
       "296  1.733892  1.798113  1.873411  ...   5.171382   4.808807   4.947419   \n",
       "297  1.557438  1.252998  1.305088  ...   4.969113   5.341223   5.259682   \n",
       "298  1.039093  1.210106  0.966492  ... -15.539719 -16.372139 -17.850698   \n",
       "299 -1.176273 -0.141477 -0.725119  ...   4.250022   3.147839   0.455908   \n",
       "\n",
       "           94         95         96         97         98         99   \\\n",
       "0       3.8634   3.717481   3.872979   3.323852   3.543512    2.99995   \n",
       "1     4.687089   4.289564   4.796074   5.063974   5.844167   6.141477   \n",
       "2     4.363564   4.293339   4.202155   4.189941   4.238253   4.283082   \n",
       "3     4.594794   5.106271   4.430222   4.995095   4.785386   5.685716   \n",
       "4     5.708839   5.857788   5.805448   5.956107   5.814142   5.778943   \n",
       "..         ...        ...        ...        ...        ...        ...   \n",
       "295   5.474327   5.261981   5.325353   5.212335   5.204316    5.07139   \n",
       "296   4.987899   4.597781   4.264246   4.327928   2.695227   5.597434   \n",
       "297   5.020607    3.92121   4.738337   5.860248   5.770157   5.132601   \n",
       "298 -17.215457 -16.700505 -17.679726 -19.059941 -19.580849 -21.198402   \n",
       "299  -0.021995   0.591024   0.563701  -2.273026  -2.617442  -1.339127   \n",
       "\n",
       "          100  \n",
       "0    3.146823  \n",
       "1     6.39985  \n",
       "2    4.337152  \n",
       "3    6.651555  \n",
       "4    6.909854  \n",
       "..        ...  \n",
       "295  5.047292  \n",
       "296   5.83875  \n",
       "297  5.633844  \n",
       "298 -23.35044  \n",
       "299 -0.502456  \n",
       "\n",
       "[300 rows x 101 columns]"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "timeline = [i*(T/100) for i in range(101)]\n",
    "valuesline = [values[i].mean() for i in range(101)]\n",
    "plt.plot(timeline,valuesline,color = 'orange')\n",
    "plt.ylabel('portfolio value')\n",
    "plt.xlabel('time')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "the hedge error is 0.4933024651460453\n"
     ]
    }
   ],
   "source": [
    "hedge_error = sum([V_values[100][i] - max(S[100][i]-K,0) for i in range(300)])/300\n",
    "print('the hedge error is '+str(abs(hedge_error)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### comparison with Black–Scholes delta hedging"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As a comparison, let's first simulate the situation without any hedging."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "simulating the hedging process\n",
      "done!\n"
     ]
    }
   ],
   "source": [
    "##hold the option without hedging\n",
    "\n",
    "values_non_hedging = pd.DataFrame(index = [k for k in range(NSim)]\\\n",
    "                 ,columns = [k for k in range(100+1)])\n",
    "c0 = bs_call(S0,K,sigma,T,r=0.03)['c']\n",
    "values_non_hedging[0] = pd.Series([0]*NSim)\n",
    "\n",
    "print('simulating the hedging process')\n",
    "for i in range(NSim):\n",
    "    #the decision index\n",
    "    index1 = choose(S[33][i],1)\n",
    "    index2 = choose(S[66][i],2)\n",
    "    \n",
    "    \n",
    "    #the hedging process\n",
    "    money = c0\n",
    "    for step in range(100+1):\n",
    "        if step != 100:\n",
    "            money = money*exp(r*T/100)\n",
    "            values_non_hedging[step][i] = money-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "        else:\n",
    "            money = money*exp(r*T/100)\n",
    "            values_non_hedging[step][i] = money-max(S[step][i]-K,0)\n",
    "                      \n",
    "print('done!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next, as before, we simulate the trading process of delta hedging, except that the decision variable here becomes the delta value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "simulating the hedging process\n",
      "done!\n"
     ]
    }
   ],
   "source": [
    "##B-S delta dynamic hedging\n",
    "\n",
    "BS_values = pd.DataFrame(index = [k for k in range(NSim)]\\\n",
    "                 ,columns = [k for k in range(100+1)])\n",
    "BS_V_values = pd.DataFrame(index = [k for k in range(NSim)]\\\n",
    "                 ,columns = [k for k in range(100+1)])\n",
    "c0 = bs_call(S0,K,sigma,T,r=0.03)['c']\n",
    "BS_values[0] = pd.Series([0]*NSim)\n",
    "BS_V_values[0] = pd.Series([c0]*NSim)\n",
    "\n",
    "\n",
    "#carry on the hedging with constant parameters.\n",
    "print('simulating the hedging process')\n",
    "for i in range(NSim):\n",
    "    delta0 = bs_call(S[0][i],K,sigma,(T/100)*(100-0),r)['delta']\n",
    "    delta1 = bs_call(S[33][i],K,sigma,(T/100)*(100-33),r)['delta']\n",
    "    delta2 = bs_call(S[66][i],K,sigma,(T/100)*(100-66),r)['delta']\n",
    "    \n",
    "    \n",
    "    #the hedging process\n",
    "    shares = 0\n",
    "    money = c0\n",
    "    for step in range(100+1):\n",
    "           \n",
    "        \n",
    "        if step == 0:#trade is made\n",
    "            shares = delta0\n",
    "            money = c0 - S[0][i]*shares - shares*S[0][i]*g\n",
    "            \n",
    "        elif step > 0 and step < 33:\n",
    "            money = money*exp(r*T/100)\n",
    "            BS_V_values[step][i] = money+shares*S[step][i]\n",
    "            BS_values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            \n",
    "        elif step == 33:#trade is made\n",
    "            money = money*exp(r*T/100)\n",
    "            BS_V_values[step][i] = money+shares*S[step][i]\n",
    "            BS_values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            #trade\n",
    "            pre_shares = shares\n",
    "            pre_v_value = money+shares*S[step][i]\n",
    "            shares = delta1\n",
    "            money = pre_v_value - S[step][i]*shares -g*S[step][i]*abs(shares-pre_shares)\n",
    "            \n",
    "        elif step > 33 and step < 66:\n",
    "            money = money*exp(r*T/100)\n",
    "            BS_V_values[step][i] = money+shares*S[step][i]\n",
    "            BS_values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            \n",
    "        elif step == 66:#trade is made\n",
    "            money = money*exp(r*T/100)\n",
    "            BS_V_values[step][i] = money+shares*S[step][i]\n",
    "            BS_values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            #trade\n",
    "            pre_shares = shares\n",
    "            pre_v_value = money+shares*S[step][i]\n",
    "            shares = delta2\n",
    "            money = pre_v_value - S[step][i]*shares -g*S[step][i]*abs(shares-pre_shares)\n",
    "            \n",
    "        elif step >66 and step != 100:\n",
    "            money = money*exp(r*T/100)\n",
    "            BS_V_values[step][i] = money+shares*S[step][i]\n",
    "            BS_values[step][i] = money+shares*S[step][i]-bs_call(S[step][i],K,sigma,(T/100)*(100-step),r)['c']\n",
    "            \n",
    "        else:\n",
    "            money = money*exp(r*T/100)\n",
    "            BS_V_values[step][i] = money+shares*S[step][i]\n",
    "            BS_values[step][i] = money+shares*S[step][i]-max(S[step][i]-K,0)\n",
    "                      \n",
    "print('done!')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's plot the portfolio values of the three over time on a single graph and then compare the hedge error."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYoAAAEGCAYAAAB7DNKzAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/Z1A+gAAAACXBIWXMAAAsTAAALEwEAmpwYAABheUlEQVR4nO2dd3gU1deA35sQEkLovUnvEAIEkA4iRaUoRdRPBRsW7OJPVOxd7F0UFQSxgAVEpIn0YugtVEF6DxBCIOV8f5zd1E3Z7G42wH2fZ57Znbn3zpmUOXPuKdeICBaLxWKxZEWAvwWwWCwWS8HGKgqLxWKxZItVFBaLxWLJFqsoLBaLxZItVlFYLBaLJVsK+VsAb1O2bFmpUaOGv8WwWCyWC4qVK1ceFZFyrs5ddIqiRo0aREVF+VsMi8ViuaAwxuzO6pyderJYLBZLtlhFYbFYLJZssYrCYrFYLNly0fkoLBaLZyQkJLB3717i4+P9LYrFB4SEhFC1alWCgoJy3ccqCovFko69e/dSrFgxatSogTHG3+JYvIiIcOzYMfbu3UvNmjVz3c+vU0/GmF7GmC3GmO3GmJEuzgcbY35wnF9ujKnhBzEtlkuK+Ph4ypQpY5XERYgxhjJlyrhtLfpNURhjAoGPgauARsCNxphGGZrdAZwQkTrAu8Ab+SulxXJpYpXExUtefrf+tChaA9tFZKeInAe+B/plaNMPGOf4PBnoZnz0F3zqSAzP9fiK5d/M8cXwFovFcsHiT0VRBdiT5vtexzGXbUQkETgJlMk4kDFmmDEmyhgTdeTIkTwJk7B9Ny/Ovp3lb02D//0PTp/O0zgWi8W/DB06lMmTJ+e5//PPP89bb72VbZuoqCgefPDBPF/jQuOiCI8VkTEiEikikeXKucxAz5Gw5uEAxFapBaNHQ4MG8PPP3hTTYrFcJERGRvLBBx/4W4x8w5+KYh9QLc33qo5jLtsYYwoBJYBjvhCmcLChUGACseUvg6VLoXx5GDAABg6Egwd9cUmLxeKCXbt20bBhQ+666y4aN25Mjx49OHv2LABr1qzh8ssvJzw8nOuuu44TJ064HGPBggW0a9eOWrVqpbMuRo8eTatWrQgPD+e5555LOf7KK69Qr149OnTowJYtW1KO//PPP4SHhxMREcHjjz9OkyZNAPj777/p3bs3oBbI7bffTpcuXahVq1Y6BfLSSy9Rv359OnTowI033pijpVJQ8Wd47D9AXWNMTVQh3ADclKHNVGAIsBQYCPwlPlq71RgoFnqW06eS4PLLYcUKePtteP55+OsvGDEChg6FypV9cXmLpWDy8MOwZo13x4yIgPfey7bJtm3bmDRpEl988QXXX389U6ZM4eabb+bWW2/lww8/pHPnzjz77LO88MILvOdirAMHDrBo0SKio6Pp27cvAwcOZNasWWzbto0VK1YgIvTt25cFCxZQtGhRvv/+e9asWUNiYiItWrSgZcuWANx222188cUXtG3blpEjMwVmphAdHc28efM4ffo09evX595772XNmjVMmTKFtWvXkpCQkG7cCw2/WRQOn8P9wExgM/CjiGw0xrxojOnraDYWKGOM2Q48CmT9m/ICYaEJxMYm65egIBg5Uv9JIiPh6aehWjXo0wc2bvSlGBbLJU/NmjWJiIgAoGXLluzatYuTJ08SExND586dARgyZAgLFixw2f/aa68lICCARo0acejQIQBmzZrFrFmzaN68OS1atCA6Oppt27axcOFCrrvuOkJDQylevDh9++rjJyYmhtOnT9O2bVsAbrop43tsKtdccw3BwcGULVuW8uXLc+jQIRYvXky/fv0ICQmhWLFi9OnTx1s/nnzHrwl3IvIH8EeGY8+m+RwPDMovecJCk4iNDQBJBuPQoQ0awKxZsG0bfPUVjBkD/fqpAgkLyy/RLBb/kMObv68IDg5O+RwYGJgy9ZSX/s5JCBHhySef5O67707X1pVF4i4Z5U1MTPR4zILEReHM9hZhYUJsfFGIP5z5ZN268Npr8MsvsHMnPPpo/gtosVzClChRglKlSrFw4UIAvv322xTrIjf07NmTr776itjYWAD27dvH4cOH6dSpE7/++itnz57l9OnTTJs2DYCSJUtSrFgxli9fDsD333/vlrzt27dn2rRpxMfHExsby++//+5W/4KELeGRhrBiAcQeC4Oz+6BIRdeNOnWCxx+HN9/UaagL2Jy0WC40xo0bxz333ENcXBy1atXi66+/znXfHj16sHnz5pSppLCwMCZMmECLFi0YPHgwzZo1o3z58rRq1Sqlz9ixY7nrrrsICAigc+fOlChRItfXa9WqFX379iU8PJwKFSrQtGlTt/oXJIyPfMN+IzIyUvK6cFHfq2LYs/lfVi/6D6pmzP1Lw7lz0KYN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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "values_non_hedgingline = [values_non_hedging[i].mean() for i in range(101)]\n",
    "BS_valuesline = [BS_values[i].mean() for i in range(101)]\n",
    "plt.plot(timeline,values_non_hedgingline,color = 'red',label = 'no hedging')\n",
    "plt.plot(timeline,valuesline,color = 'orange',label = 'RHC&SP hedging')\n",
    "plt.plot(timeline,BS_valuesline,color = 'blue',label = 'BS delta hedging')\n",
    "plt.xlabel('time')\n",
    "plt.ylabel('portfolio value')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "no hedging          0.676353\n",
       "BS delta hedging    0.667863\n",
       "RHC&SP hedging      0.493302\n",
       "Name: hedge error, dtype: float64"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "comparision = pd.Series({'no hedging' : abs(values_non_hedgingline[-1]),\\\n",
    "                        'BS delta hedging': abs(BS_valuesline[-1]),\\\n",
    "                        'RHC&SP hedging': abs(valuesline[-1])})\n",
    "comparision = comparision.rename('hedge error')\n",
    "comparision"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It can be seen from the chart that RHC&SP hedging works better than BS delta hedging and non-hedging almost all the time.BS delta hedging doesn't work well because it has three cliff drops and remain relatively lower value.In these scenarios, the cliff drops were the result of large trading costs incurred by the sharp shift in hedged assets as stock prices soared.By contrast, RHC&SP hedging is a little bit more stable, which suggests that the new method is more effective with transaction costs.\n",
    "\n",
    "It's understandable that BS delta hedging is inferior to non-hedging, because BS was proposed without taking transaction costs into account,which results in much more frequent transaction and more transaction costs. BS delta hedging is the most smooth on the whole, but it has three cliff drops at t=0, t =0.04 and t=0.08 due to transaction costs, especially at t =0, which directly causes its net value to remain relatively low in the subsequent process.The portfolio value of RHC&SP hedging features obvious synchronization with the non-hedging one for the reason that they hold short position of call option which is sensitive to stock price booming, but the former is more stable, which indicates its superiority.\n",
    "\n",
    "As for hedge error,RHC&SP hedging is obviously lower than the other two scenarios with an error of 0.493 while the other two scenarios' hedging error are both approsimately 0.67, which means RHC&SP hedging is superior to the other two methods."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conclusion and discussions\n",
    "- Why do the optimal parameters behave unsteadily?\n",
    "\n",
    "There is a fatal problem in the above simulation process, that is, when we repeat it many times, we find that the optimal decision variables obtained by each simulation are quite different. Moreover, their back test performance is also different. This makes us doubt the reliability of this methology. \n",
    "\n",
    "After analysis, we believe that the main reason is that we have too few Monte Carlo simulations and we have not selected enough rebalancing points. In fact, there is a reason for this. We have to admit that the above implementation of this method depends heavily on the module of gurobipy. However, when using this module, trial users can only test a limited data scale, and license is required to further expand the data scale. This is why in our example, we only set the number of samples to 300 and the rebalancing point to 3.\n",
    "\n",
    "Here we are only to show the essence of this strategy, and its optimal parameters may not have practical significance. However, we have no reason to doubt that when we expand the sample size and increase the rebalancing points, the parameter stability will be improved, and the performance of this methology will be much better than that of the traditional delta hedging — especially when there are transaction costs.\n",
    "-  Some areas of flexibility of this methodology\n",
    "\n",
    "Compared to the traditional Black-Merton-Scholes dynamic hedging model, this model is more flexible in various aspects. \n",
    "\n",
    "The first is the ease with which we can input any objective function we would like into the methodology, any objective function can get the optimal value in this model. For example, sometimes we use the utility function as the objective function, which is widely used in financial economics. \n",
    "\n",
    "The second is that this method can be applied to both one and multi-dimensional options. This means that we can solve the optimal case with more complex portfolio under this model. (Limited to time, we only show the case of single option hedging).\n",
    "\n",
    "The third is that this methodology can easily be used with any model of asset dynamics for the underlying. This shows the high suitability of the underlying portfolio form of the model. \n",
    "\n",
    "To sum up, when we change the definite hedging strategy into a more variable optimization model, although it makes everything more complex, it has been greatly improved, not only in performance but also in flexibility. When we ask it for the optimal solutions instead of establishing a specific way to calculate the recommended holding numbers, it provides us more possibilities. I increasingly believe that the sentence 'Let it go' makes perfect sense.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Reference\n",
    "\n",
    "[1]  Peter J. Meindl & James A. Primbs (2008) Dynamic hedging of single and\n",
    "multi-dimensional options with transaction costs: a generalized utility maximization approach, Quantitative Finance, 8:3, 299-312\n",
    "\n",
    "[2] Jacob Mattingley, Yang Wang, and Stephen Boyd (2011) Receding Horizon Control, IEEE CONTROL SYSTEMS MAGAZINE, 10.1109/MCS.2011.940571\n",
    "\n",
    "[3] Alexander Shapiro (2001) MONTE CARLO SIMULATION APPROACH TO STOCHASTIC PROGRAMMING, School of Industrial & Systems Engineering Georgia Institute of Technology Atlanta, Georgia 30332, U.S.A.\n"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Slideshow",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": false,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
